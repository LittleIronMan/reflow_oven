syntax = "proto3";
import "nanopb.proto";

// Этот тип перечисляет все возможные типы сообщений, которые будут далее определены.
// При передаче данных этот тип должен дополнять отправляемый пакет(в котором будет закодированное сообщение),
// чтобы принимающие стороны знали каким образом это сообщение декодировать
enum PB_MsgType {
	UNDEFINED = 0;
	CMD = 1; // команда
	RESPONSE = 2; // ответ на команду
	RESPONSE_GET_TEMP_PROFILE = 3; // ответ на команду GET_TEMP_PROFILE(большого размера, поэтому рассматривается особняком)
	TEMP_MEASURE = 4; // контроллер отправляет серверу текущее измерение температуры
	RESPONSE_TEMP_MEASURE = 5; // сервер отвечает что измерение было успешно принято
	FINISH_PROGRAM = 6; // котроллер оправляет серверу команду что он успешно завершил программу
	PLAIN_TEXT = 7; // простой текст
	SWITCH_OVEN_STATE = 8; // сообщение от контроллера с информацией о переключении состояния печки(включена/выключена)
}

enum PB_CmdType {
	GET_TEMP_PROFILE = 0;
	GET_STATE = 1;
	START = 2;
	STOP = 3;
	HARD_RESET = 4; // сигнал(не команда) от микроконтроллера серверу и клиенту сбросить все свои данные, отдается или при перезапуске контроллера
	CLIENT_REQUIRES_RESET = 5; // запрос от веб-клиента микроконтроллеру на сброс всех данных(например по нажатию специальной кнопки в веб-интерфейсе), после этого контроллер должен дать серверу команду на сброс
	MANUAL_ON = 6; // ручное переключение нагревателя, если до этого была включена какая-то автоматическая программа стабилизации температуры, то она продолжит выполняться фоном(т.е. время для неё продолжить тикать, но печка переключаться не будет)
	MANUAL_OFF = 7;
}

message PB_Command {
	PB_CmdType cmdType = 1;
	uint32 id = 2;
	uint32 priority = 3 [(nanopb).int_size = IS_8]; // [default = 1]; // чем больше эта величина, тем выше приоритет
}

message PB_TempMeasure {
	uint32 time = 1;
	float mills = 2; // [(nanopb).int_size = IS_16]; // миллисекунды времени
	float temp = 3;
}

message PB_TempProfile {
	uint32 countPoints = 1 [(nanopb).int_size = IS_8]; // количество "точек" в термопрофиле
	repeated PB_TempMeasure data = 2 [(nanopb).max_count = 10, (nanopb).fixed_count = true];
}

message PB_ResponseGetTempProfile {
	bool success = 1; // [default = true];
	PB_TempProfile profile = 2;
}

enum PB_ProgramState {
	STOPPED = 0;
	LAUNCHED = 1;
}

enum PB_OvenState {
	OFF = 0;
	ON = 1;
}

enum PB_ControlMode {
	DEFAULT_OFF = 0;
	TEMP_PROFILE = 1;
	HOLD_CONST_TEMP = 2;
	MANUAL = 3;
}

enum PB_ErrorType {
	NONE = 0;
	FAULTY_TEMPERATURE_SENSOR = 1;
	FAULTY_RELAY = 2;
	UNKNOWN_COMMAND = 3;
	UNKNOWN_ERROR = 4;
}

message PB_Response {
	PB_CmdType cmdType = 1;
	uint32 cmdId = 2;
	bool success = 3;
	PB_ControlMode controlMode = 4;
	PB_ProgramState programState = 5;
	PB_OvenState ovenState = 6;
	PB_ErrorType error = 7; // [default = NONE];
	uint32 time = 8; // некоторые ответы на команды будут возвращать величину времени, это специально отведеное для этого поле
	float mills = 9; // [(nanopb).int_size = IS_16]; // миллисекунды времени
}

message PB_SwitchOvenState {
	uint32 time = 1;
	float mills = 2;
	PB_OvenState ovenState = 3;
}
